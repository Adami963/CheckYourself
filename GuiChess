import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.*;
import java.io.*;
import java.util.ArrayList;
import java.util.List;

//Main do not change this
public class GUIChess extends JFrame{
    //core game
    private BoardGUI boardGUI;
    private GameLogic gameLogic;

    //extra features
    private MenuManager menuManager;
    private GameHistoryPanel historyPanel;

    //game state
    private boolean gameActive = true;
    //constructor
    public GUIChess(){
        super("chess Game");
        initializeComponents();
        setupGUI();
        startNewGame();
    }

    private void initializeComponents(){
        //core game components
        this.boardGUI = new boardGUI();
        this.gameLogic = new GameLogic();

        //extra fetures
        this.menuManager = new MenuManager(this);
        this.historyPanel = new GameHistoryPanel();

        setupComponentConnections();
    }

    private void setupComponentConnections(){

        boardGUI.setMoveListener((fromRow, fromCol, toRow, toCol) -> {

            if (gameActive){
                boolean validMove = gameLogic.handleMove(fromRow, fromCol, toRow, toCol);
                if(validMove){
                    boardGUI.updateBoard(gameLogic.getBoardState());

                    historyPanel.addMove(gameLogic.getLastMoveDescription());
                    historyPanel.updateCapturePieces(gameLogic.getCapturedWhitePieces()), gameLogic.getCapturedBlackPieces());

                    if(gameLogic.isGameOver()){
                        handleGameEnd();
                    }
                }
            }

        });
            
        

        historyPanel.setUndoListener(() -> {
            if(gameLogic.undoMove()){
                boardGUI.updateBoard(gameLogic.getBoardState());
                historyPanel.updateMoveHistory(gameLogic.getMoveHistory());
                historyPanel.updateCapturePieces(gameLogic.getCapturedWhitePieces(), gameLogic.getCapturedBlackPieces());

                gameActive = true;
            }
        });
    }

    private void setupGUI(){
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());

        setJMenuBar(menuManager.createMenuBar());

        add(boardGUI.getBoardPanel(), BorderLayout.CENTER);
        add(historyPanel.getPanel(), BorderLayout.EAST);

        pack();
        setLocationRelative(null);
    }

    public void startNewGame(){
        gameLogic.initializeNewGame();
        boardGUI.initializeBoard();
        historyPanel.clearHistory();
        gameActive = true;
    }

    private void handleGameEnd(){
        gameActive = false;
        String winner = gameLogic.getWinner();
        JOptionPane.showMessageDialog(this, "Game Over!" + winner + "wins!", "Game Finished", JOptionPane.INFORMATION_MESSAGE);

    }

    public void saveGame(){
        menuManager.saveGame(gameLogic.getGameState());
    }

    public void loadGame(){
        GameState loadedState = menuManager.loadGame();
        if(loadedState != null) {
            gameLogic.loadedGameState(loadedState);
            boardGUI.updateBoard(gameLogic.getBoardState());
            historyPanel.updateMoveHistory(gameLogic.getCapturedWhitePieces(), gameLogic.getCapturedBlackPieces());

            gameActive =!gameLogic.isGameOver();
        }
    }

    public static void main(String[] args){
        SwingUtilities.invokeLater(() -> {
            GUIChess chessGame = new GUIChess();
            chessGame.setVisible(true);
        });
    }
//interface for the notification from boardGUI to gameLogic
    interface MoveListener {
        void onMoveMade(int fromRow, in fromCol, int toRow, int toCol);
    }

    //Teammate 1: All visual of the chess board 
    //Display 8x8 chessboard with alternating light/dark squares
     //Display chess pieces on their initial positions  
     //Handle user interactions (click and move)
     //Visually update the board after moves
     //Highlight selected pieces


//Teammate 2: all game rules and state of game
     //Maintain current board state
     //Handle piece movement logic  
     //Detect captures and update piece positions
     //Check for game end conditions (king capture)
     //Manage game history for undo functionality

//both teammates can use this  data structures
    
    static class Piece implements Serializable {
        private static final long serialVersionUID = 1L;
        
        public enum Type {
            KING, QUEEN, ROOK, BISHOP, KNIGHT, PAWN
        }
        
        public enum Color {
            WHITE, BLACK
        }
        
        private Type type;
        private Color color;
        
        public Piece(Type type, Color color) {
            this.type = type;
            this.color = color;
        }
        
        public Type getType() { return type; }
        public Color getColor() { return color; }
        
       
        public String getSymbol() {
            switch(type) {
                case KING: return color == Color.WHITE ? "♔" : "♚";
                case QUEEN: return color == Color.WHITE ? "♕" : "♛";
                case ROOK: return color == Color.WHITE ? "♖" : "♜";
                case BISHOP: return color == Color.WHITE ? "♗" : "♝";
                case KNIGHT: return color == Color.WHITE ? "♘" : "♞";
                case PAWN: return color == Color.WHITE ? "♙" : "♟";
                default: return "";
            }
        }
        
        @Override
        public String toString() {
            return color + " " + type;
        }
    }
    
    
    static class Move implements Serializable {
        private static final long serialVersionUID = 1L;
        int fromRow, fromCol, toRow, toCol;
        Piece pieceMoved;
        Piece pieceCaptured;
        
        Move(int fromRow, int fromCol, int toRow, int toCol, Piece pieceMoved, Piece pieceCaptured) {
            this.fromRow = fromRow;
            this.fromCol = fromCol;
            this.toRow = toRow;
            this.toCol = toCol;
            this.pieceMoved = pieceMoved;
            this.pieceCaptured = pieceCaptured;
        }
    }
    
  
    static class GameState implements Serializable {
        private static final long serialVersionUID = 1L;
        Piece[][] board;
        boolean isWhiteTurn;
        boolean gameOver;
        String winner;
        List<Move> moveHistory;
        List<Piece> capturedWhitePieces;
        List<Piece> capturedBlackPieces;
        
        GameState(Piece[][] board, boolean isWhiteTurn, boolean gameOver, String winner,
                 List<Move> moveHistory, List<Piece> capturedWhitePieces, List<Piece> capturedBlackPieces) {
            this.board = board;
            this.isWhiteTurn = isWhiteTurn;
            this.gameOver = gameOver;
            this.winner = winner;
            this.moveHistory = moveHistory;
            this.capturedWhitePieces = capturedWhitePieces;
            this.capturedBlackPieces = capturedBlackPieces;
        }
        
        GameState() {
            // Default constructor
        }
    }


//Extra Feature- Adami

static class MenuManager{
    private ChessGameGUI mainFrame;

    public MenuManager(ChessGameGUI frame){
        this.mainFrame = frame;
    }
    /**
     * Main Menu Bar
     */

    public JMenuBar createMenuBar(){
        JMenuBar menuBar = new JMenuBar();

        JMenu gameMenu = new JMenu("Game");

        JMenuItem newGameItem = new JMenuItem("New Game");
        newGameItem.addActionListener(e -> mainFrame.startNewGame());

        JMenuItem saveGameItem = new JMenuItem("Save Game");
        saveGameItem.addActionListener(e -> mainFrame.saveGame());

        JMenuItem loadGameItem = new JMenuItem("Load Game");
        loadGameItem.addActionListener(e -> mainFrame.loadGame());

        JMenuItem exitItem = new JMenuItem("Exit");
        exitItem.addActionListener(e -> System.exit(0));
        
        gameMenu.add(newGameItem);
        gameMenu.add(saveGameItem);
        gameMenu.add(loadGameItem);

        gameMenu.addSeparator();
        gameMenu.add(gameMenu);

        return menuBar;
    }

    /**
     * Save Game File
     */

     public void saveGame(Gamestate gameState){
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Save Game");
        
        int userSelection = fileChooser.showsSaveDialog(mainFrame);
        if (userSelection == JFileChooser.APPROVE_OPTION){
            File fileToSave = fileChooser.getSelectedFile();
            try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(fileToSave)))
            {
                oos.writeObject(gameState);
                JOptionPane.showMessageDialog(mainFrame, "Game saved successfully!" + ex.getMessage(), "Save Error", JOption.ERRO_MESSAGE);

            }
        }
     }
/**
 * Load Game File
 */

 public GameState loadGame(){
    JFileChooser fileChooser = new JFileChooser();
    fileChooser.setDialogTitle("Load Game");

    int userSelection = fileChooser.showOpenDialog(mainFrame);
    if (userSelection == JFileChooser.APPROVE_OPTION){
        File fileToLoad = fileChooser.getSelectedFile();
        try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileToLoad)))
        {
            GameState state = (GameState) ois.readObject();
            JOptionPane.showMessageDialog(mainFrame, "Game loaded successfully!", "Load Game", JOptionPane.INFORMATION_MESSAGE);
            return state;
        } catch(IOException | ClassNotFoundException ex){
            JOptionPane.showMessageDialog(mainFrame, "Error loading game: " + ex.getMessage(), "Load Error", JOptionPane.ERROR_MESSAGE);

        }
    }
    return null;
 }

 /**
  * Game History
  */
  static class GameHistoryPanel{
    private Jpanel mainPanel;
    private JTextArea moveHistoryArea;
    private JPanel capturePiecesPanel;
    private JButton undoButton;
    private ActionListener undoListener;

    public GameHistoryPanel(){
        initializeComponents();
    }

    private void initializeComponents(){
        mainPanel = newJPanel(new BorderLayout());
        mainPanel.setPreferredSize(new Dimension(250,600));
        mainPanel.setBorder(BorderFactory.createTitledBorder("Game History"));

        JLabel historyLabel = new JLabel("Move History:");
        moveHistoryArea = new JTextArea(20,20);
        moveHistoryArea.setEditable(false);
        JScrollPane scrollPane = newJScrollPane(moveHistoryArea);

        JLabel captureLabel = new JLabel("Capture Pieces: ");
        capturedPiecesPanel = new JPanel();
        capturedPiecesPanel.setLayout(new BoxLayout(capturedPiecesPanel));
        JScrollPane capturedScrollPane = new JScrollPane(capturedPiecesPanel);
        capturedScrollPane.setPreferredSize(new Dimension(230, 150));

        undoButton = new JButton("Undo Move");
        undoButton.addActionListener(e -> {
            if(undoListener != null){
                undoListener.actionPerformed(e);
            }
        });

        mainPanel.add(historylabel, BorderLayout.North);
        mainPanel.add(scrollPane, borderLayout.CENTER);

        Jpanel southPanel = new JPanel(new BorderLayout());
        southPanel.add(capturedLabel, BorderLayout.NORTH);
        southPanel.add(capturedScrollPane, BorderLayout.CENTER);
        southPanel.add(undoButton, BorderLayout.SOUTH);

        mainPanel.add(SouthPanel, BorderLayout.South);

        
    }

    public JPanel getPanel()[
        return mainPanel;
    ]

    public void addMove(String moveDescription){
        moveHistoryArea.append(moveDescription + "\n");
    }
/**
 * Update move history
 */
    public void updateMoveHistory(List<String> moves){
        moveHistoryArea.setText("");
        for(String move : moves){
            moveHistoryArea.append(move + "\n");
        }
    }
    /**
     * Updated Captured pieces
     */

    public void updateCapturePieces(List<Piece> capturedWhite, List<Piece> captureBlack){
        capturedPiecesPanel.removeAll();
        //White Pieces
        JLabel whiteLabel = new JLabel("White captured:");
        capturedPiecesPanel.add(whiteLabel);

        JPanel whitePiecesPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        for(Piece piece : capturedWhite){
            JLabel pieceLabel = new Jlabel(piece.getSymbol());
            pieceLabel.setFont(new font ("Serif", Font.PLAIN, 20));
            whitePiecesPanel.add(pieceLabel);
        }
        capturedPiecesPanel.add(whitePiecesPanel);
//Black Pieces
        JLabel blackLabel = new JLabel("Black captured:");
        capturedPiecesPanel.add(blackLabel);

        JPanel blackPiecesPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        for(Piece piece : capturedBlack){
            JLabel pieceLabel = new JLabel(piece.getSymbol());
            pieceLabel.setFont(new Font("Serif", Font.PLAIN, 20));
            blackPiecesPanel.add(pieceLabel);
        }
        capturedPiecesPanel.add(blackPiecesPanel);

        capturedPiecesPanel.add(blackPiecesPanel);

        capturePiecesPanel.revalidate();
        capturedPiecesPanel.repaint();
    }
    /**
     * Clear History
     */
    public void clearHistory(){
        moveHistoryArea.setText("");
        capturedPiecesPanel.removeAll();
        capturedPiecesPanel.revalidate();
        capturedPiecesPanel.repaint();

    }
    /**
     * Undo Button
     */

    public void setUndoListener(ActionListener listener){
        this.undoListener = listener;
    }
    
  }

}




}
